import numpy as np
import transformation as tf

def neumann_bc(x, nx):
    """
    Apply Neumann boundary conditions to the given value.

    Args:
        x (int): The value to apply the boundary conditions to.
        nx (int): The maximum value allowed.

    Returns:
        the modified value
    """
    # Apply Neumann boundary conditions as vectorized operation
    out = np.copy(x)
    out = np.where(out < 0, 0, out)
    out = np.where(out >= nx, nx - 1, out)

    return out


def cubic_interpolation(v: np.ndarray, x: float) -> float:
    """
    Performs cubic interpolation using the given control points and the interpolation parameter.

    Parameters:
        v (np.ndarray): The array of control points.
        x (float): The interpolation parameter.

    Returns:
        float: The interpolated value.

    """
    return v[1] + 0.5 * x * (v[2] - v[0]
                             + x * (2.0 * v[0] - 5.0 * v[1] + 4.0 * v[2] - v[3]
                                    + x * (3.0 * (v[1] - v[2]) + v[3] - v[0])))


def bicubic_interpolation_array(p, x, y):
    """
    Bicubic interpolation in two dimensions.

    Parameters:
    p (np.ndarray): 4x4 array containing the interpolation points
    x (float): x position to be interpolated
    y (float): y position to be interpolated

    Returns:
    float: Interpolated value
    """
    v = np.zeros(4)
    v[0] = cubic_interpolation(p[0], y)
    v[1] = cubic_interpolation(p[1], y)
    v[2] = cubic_interpolation(p[2], y)
    v[3] = cubic_interpolation(p[3], y)
    return cubic_interpolation(v, x)


def bicubic_interpolation_point(input, uu, vv, nx, ny, nz, k):
    """
    Performs bicubic interpolation at a given point.

    Args:
        input (ndarray): Input array of shape (nx * ny * nz,) containing the image data.
        uu (float): The x-coordinate of the point to interpolate.
        vv (float): The y-coordinate of the point to interpolate.
        nx (int): The width of the image.
        ny (int): The height of the image.
        nz (int): The number of channels in the image.
        k (int): The channel index to interpolate.

    Returns:
        float: The interpolated value at the given point.
    """
    sx = np.where(uu < 0, -1, 1)
    sx = sx.astype(np.int32)
    sy = np.where(vv < 0, -1, 1)
    sy = sy.astype(np.int32)
    # sx = [-1 if uu < 0 else 1]
    # sy = [-1 if vv < 0 else 1]
    
    x = neumann_bc(uu.astype(np.int32), nx)
    y = neumann_bc(vv.astype(np.int32), ny)
    mx = neumann_bc(uu.astype(np.int32) - sx, nx)
    my = neumann_bc(vv.astype(np.int32) - sy, ny)
    dx = neumann_bc(uu.astype(np.int32) + sx, nx)
    dy = neumann_bc(vv.astype(np.int32) + sy, ny)
    ddx = neumann_bc(uu.astype(np.int32) + 2 * sx, nx)
    ddy = neumann_bc(vv.astype(np.int32) + 2 * sy, ny)
    
    p = input[np.ix_([my, y, dy, ddy], [mx, x, dx, ddx], [k])].transpose(1, 0, 2)
    
    return bicubic_interpolation_array(p, uu - x, vv - y)


def bicubic_interpolation_image(
    input, 
    params, 
    transform_type, 
    nanifoutside, 
    delta):
    
    ny, nx, nz = input.shape
    output = np.zeros((ny, nx, nz), dtype=np.float64)

    nparams = transform_type.nparams()

    if nanifoutside:
        out_value = np.nan
    else:
        out_value = 0.0
    
    # Vectorize the transformation
    jj, ii = np.meshgrid(np.arange(nx), np.arange(ny))
    x, y = tf.project(jj, ii, params, transform_type)
    
    out = (x < delta) | (x > nx - 1 - delta) | (y < delta) | (y > ny - 1 - delta)
    output[out] = out_value

    valid = ~out
    for k in range(nz):
        output[valid, k] = bicubic_interpolation_point(input, x[valid], y[valid], nx, ny, nz, k)
    
    return output


